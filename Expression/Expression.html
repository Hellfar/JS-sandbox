<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en" dir="ltr">
	<head>
		<meta charset="UTF-8" >
		<title>Expression</title>
		<script type="text/javascript" src="peg-0.9.0.js" ></script>
		<script type="text/javascript" src="../js/Type/Primary/Object/Object.js" ></script>
		<script type="text/javascript" src="../js/Type/Primary/Array/Array.js" ></script>
	</head>
	<body>
		<div id="workspace" >
			<div id="output" ></div>
			<input type="button" value="add an expression" onclick="Javascript:addElements(NS['html'], entries, [{'tag':'br'},{'tag':'input','placeholder':'expr','value':'4*(1+2+3)-5+-6'}]);" /><input type="button" value="evaluate" onclick="Javascript:calc();" />
			<div id="entries" ></div>
			<script>
function		Expr(  )
{
	var			l_arguments = arguments.length;

	this.dicInterp =
				{
					'i':{'type':'ignore', 'state':/[ \t\n\r]+/},
					'ge':{'type':'group_end', 'state':'\\)'},
					'g':{'type':'group', 'state':'\\(', 'solve':true, 'closure':'ge'},
					'o':{'type':'binary', 'state':/\+|-|\*|\/|%|=/, 'left':'ge,v,n', 'right':'g,v,n', 'func':Expr.prototype.binOpe},
					/*'f':{'type':'unary', 'state':'-', 'right':'g,v,n', 'func':(function (e){return ((new Expr()).tokenize(new String(-1 * ~~e)));})},*/
					'v':{'type':'various', 'state':/-?[a-zA-Z]+/},
					'n':{'type':'number', 'state':/-?\d+(\.\d+)?/},
				};
	this.tokenSets = []; // form: [[{'type':'g|v|n|o', 'value':'string or object child form'}, {...}], [...]]
	this.stack = {}; // variables that have to be stored.

	for (var i = 0; i < l_arguments; i++)
		this.set(arguments[i]);
}
Expr.prototype.binOpe =
				function		std_Expr_binOpe( dic, operator, right, left )
				{
					var			ret = null,
								operator = operator.value,
								right = (dic[right.type].type == 'number') ? ~~right.value : right.value,
								left = (dic[left.type].type == 'number') ? ~~left.value : left.value;

					switch (operator)
					{
						case ('+'):
							ret = left + right;
						break;
						case ('-'):
							ret = left - right;
						break;
						case ('*'):
							ret = left * right;
						break;
						case ('/'):
							ret = left / right;
						break;
						case ('%'):
							ret = left % right;
						break;
						case ('='):
							ret = this.stack[left] = right;
						break;
					};

					return ((new Expr()).tokenize(new String(ret))[0]);
				};
Expr.prototype.groupParser =
				function	std_Expr_groupParser( e, dic, seeking )
				{
					var		type = dic[e.type];

					/*console.log(e, type.type, seeking, type.type == 'group_end');*/
					if (dic[e.type].type == 'group')
						seeking.unshift(dic[e.type].closure);
					else if (dic[e.type].type == 'group_end' && seeking.pop() == e.type)
						return(true);

					return (false);
				};
Expr.prototype.tokenize =
				function		std_Expr_tokenize( s_exprs )
				{
					var			ret = [],
								a_exprs = s_exprs.split(';').filter(function(e){return (e.length);})
								l_a_exprs = a_exprs.length,
								dicKeys = this.dicInterp.properties(),
								regs = dicKeys.map(function(e){return (this.dicInterp[e].state);}, this),
								l_regs = regs.length;

					for (var i = 0; i < l_a_exprs; i++)
					{
						var		expr = a_exprs[i];

						while (expr.length)
						{
							var		t_val = null;

							for (var e = 0; e < l_regs; e++)
							{
								var	dic = this.dicInterp[dicKeys[e]];

								if ((t_val = expr.match(regs[e])) && dic.type != 'binary'
									|| (ret.last() != undefined && dic.type == 'binary'
										&& dic.left.split(',').indexOf(ret.last().type) != -1))
									if (t_val = t_val.testIf(function(e){return (e.index==0);}, null))
									{
										t_val = t_val[0];
										break;
									}
							}
							if (t_val == null)
								throw new SyntaxError("Expression: At index "+ (a_exprs[i].length - expr.length) +" on case \""+ expr +"\" for the expression \""+ a_exprs[i] +"\"");
							ret.push({'type':dicKeys[e], 'value':t_val});
							expr = expr.substr(t_val.length);
						}
					}

					return (ret);
				};
Expr.prototype.polishize =
				function		std_Expr_polishize( tokens )
				{
					var			ret = [];

					for (var token; token = tokens.shift(); )
						switch (this.dicInterp[token.type].type)
						{
							case ('ignore'):
								break;
							case ('group'):
								{
									var	groupEnd = tokens.search(this.groupParser, [this.dicInterp, [this.dicInterp[token.type].closure]]);

									if (groupEnd == -1)
										throw new SyntaxError("Expression: Missing end of group waiting for match \""+ this.dicInterp[this.dicInterp[token.type].bind].state +"\" began with match \""+ this.dicInterp[token.type].state +"\"");
									ret = ret.concat(this.polishize(tokens.splice(0, groupEnd + 1).slice(0, groupEnd)));
								};
								break;
							case ('various'):
								ret.push(token);
								break;
							case ('number'):
								ret.push(token);
								break;
							case ('binary'):
								{
									if (!(tokens.length))
										throw new SyntaxError("Expression: A binary operator which is \""+ token.value +"\" with type \""+ token.type +"\" must have two operand");
									ret = ret.concat(this.polishize(tokens));
									ret.push(token);
								};
								break;
						}

					return (ret);
				};
Expr.prototype.polishizeAll =
				function		std_Expr_polishizeAll( tokenSets )
				{
					var			ret = [],
								l_tokenSets = tokenSets.length;

					for (var i = 0; i < l_tokenSets; i++)
						ret.push(this.polishize(tokenSets[i]));

					return (ret);
				};
Expr.prototype.set =
				function		std_Expr_set( s_exprs )
				{
					this.tokenSets.push(this.tokenize(s_exprs));

					return (this);
				};
Expr.prototype.evaluate =
				function		std_Expr_evaluate(  )
				{
					var			polishes = this.polishizeAll(this.tokenSets),
								a_pile = [];

					for (var polish; polish = polishes.shift(); )
						for (var token; token = polish.shift(); )
						{
							var	type = this.dicInterp[token.type];

							switch (type.type)
							{
								case ('various'):
								{
									var	v = this.stack[token.value];

									if (v)
										a_pile.push((new Expr()).tokenize(new String(v))[0]);
									else
										a_pile.push(token);
								};
								break;
								case ('number'):
									a_pile.push(token);
								break;
								case ('binary'):
									a_pile.push(type.func.call(this, this.dicInterp, token, a_pile.pop(), a_pile.pop()));
								break;
							}
						}

					return (a_pile);
				};
Expr.prototype.toString =
				function		std_Expr_toString(  )
				{
					var			ret = "",
								tokenSets = this.tokenSets,
								l_tokenSets = this.tokenSets.length;

					for (var i = 0; i < l_tokenSets; i++)
					{
						var		tokens = tokenSets[i],
								l_tokens = tokens.length;

						if (i != 0)
							ret += ";";
						for (var e = 0; e < l_tokens; e++)
							ret += tokens[e].value;
					}

					return (ret);
				};

				function		calc(  )
				{
					var			inputs = Array.prototype.slice.call(document.querySelectorAll("#entries input")).map(function(e){return (e.value);}).filter(function(e){return (e.length);}),
								l_inputs = inputs.length,
								exprs = new Expr();

					output.innerHTML = "";
					for (var i = 0; i < l_inputs; i++)
						exprs.set(inputs[i]);
					inputs = exprs.evaluate();
					for (var i = 0; i < l_inputs; i++)
					{
						if (i != 0)
							output.innerHTML += "<br />";
						output.innerHTML += inputs[i].value;
					}
				}

				var				NS = {
					'html'		:'http://www.w3.org/1999/xhtml',
					'svg'		:'http://www.w3.org/2000/svg'
				};

				function			addElements( ns, parent, elems )
				{
					var				a_o = [];

					switch (typeof(elems))
					{
						case ("string"):
						{
							var		o = document.createTextNode(elems);

							parent.appendChild(o);
							a_o.push(o);
						};
						break;
						case ("object"):
						{
							var		l_elems;

							if (elems.constructor != Array)
								elems = [elems];
							l_elems = elems.length;
							for (var i = 0; i < l_elems; i++)
							{
								var	elem = elems[i],
									o;

								if (elem.tag == "#text")
									o = document.createTextNode(elem.value);
								else
								{
									o = document.createElementNS(ns, elem.tag);
									delete (elem.tag);
									if (typeof (elem.child) != "undefined")
										addElements(ns, o, elem.child);
									delete (elem.child);
									for (attr in elem)
										if (elem.hasOwnProperty(attr) && elem[attr])
											o.setAttributeNS(null, attr, elem[attr]);
								}
								parent.appendChild(o);
								a_o.push(o);
							}
						};
						break;
					}
					return (a_o);
				}
			</script>
		</div>
	</body>
</html>
